import { HttpErrorResponse, HttpHeaders } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { of, throwError, timer } from 'rxjs';
import { catchError, mergeMap, retryWhen, switchMap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../../utils/url/url.service";
import * as i2 from "../../logging/logger.service";
import * as i3 from "../../api/data.service";
import * as i4 from "../../storage/storage-persistence.service";
class RefreshTokenCallbackHandlerService {
    constructor(urlService, loggerService, dataService, storagePersistenceService) {
        this.urlService = urlService;
        this.loggerService = loggerService;
        this.dataService = dataService;
        this.storagePersistenceService = storagePersistenceService;
    }
    // STEP 2 Refresh Token
    refreshTokensRequestTokens(callbackContext, config, customParamsRefresh) {
        let headers = new HttpHeaders();
        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');
        const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);
        const tokenEndpoint = authWellknownEndpoints?.tokenEndpoint;
        if (!tokenEndpoint) {
            return throwError(() => new Error('Token Endpoint not defined'));
        }
        const data = this.urlService.createBodyForCodeFlowRefreshTokensRequest(callbackContext.refreshToken, config, customParamsRefresh);
        return this.dataService.post(tokenEndpoint, data, config, headers).pipe(switchMap((response) => {
            this.loggerService.logDebug(config, 'token refresh response: ', response);
            response.state = callbackContext.state;
            callbackContext.authResult = response;
            return of(callbackContext);
        }), retryWhen((error) => this.handleRefreshRetry(error, config)), catchError((error) => {
            const { authority } = config;
            const errorMessage = `OidcService code request ${authority}`;
            this.loggerService.logError(config, errorMessage, error);
            return throwError(() => new Error(errorMessage));
        }));
    }
    handleRefreshRetry(errors, config) {
        return errors.pipe(mergeMap((error) => {
            // retry token refresh if there is no internet connection
            if (error &&
                error instanceof HttpErrorResponse &&
                error.error instanceof ProgressEvent &&
                error.error.type === 'error') {
                const { authority, refreshTokenRetryInSeconds } = config;
                const errorMessage = `OidcService code request ${authority} - no internet connection`;
                this.loggerService.logWarning(config, errorMessage, error);
                return timer(refreshTokenRetryInSeconds * 1000);
            }
            return throwError(() => error);
        }));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: RefreshTokenCallbackHandlerService, deps: [{ token: i1.UrlService }, { token: i2.LoggerService }, { token: i3.DataService }, { token: i4.StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: RefreshTokenCallbackHandlerService, providedIn: 'root' }); }
}
export { RefreshTokenCallbackHandlerService };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: RefreshTokenCallbackHandlerService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.UrlService }, { type: i2.LoggerService }, { type: i3.DataService }, { type: i4.StoragePersistenceService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVmcmVzaC10b2tlbi1jYWxsYmFjay1oYW5kbGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLWF1dGgtb2lkYy1jbGllbnQvc3JjL2xpYi9mbG93cy9jYWxsYmFjay1oYW5kbGluZy9yZWZyZXNoLXRva2VuLWNhbGxiYWNrLWhhbmRsZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsV0FBVyxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDdEUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQWMsRUFBRSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDekQsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7Ozs7QUFRNUUsTUFDYSxrQ0FBa0M7SUFDN0MsWUFDbUIsVUFBc0IsRUFDdEIsYUFBNEIsRUFDNUIsV0FBd0IsRUFDeEIseUJBQW9EO1FBSHBELGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDNUIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFDeEIsOEJBQXlCLEdBQXpCLHlCQUF5QixDQUEyQjtJQUNwRSxDQUFDO0lBRUosdUJBQXVCO0lBQ3ZCLDBCQUEwQixDQUN4QixlQUFnQyxFQUNoQyxNQUEyQixFQUMzQixtQkFBa0U7UUFFbEUsSUFBSSxPQUFPLEdBQWdCLElBQUksV0FBVyxFQUFFLENBQUM7UUFFN0MsT0FBTyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLG1DQUFtQyxDQUFDLENBQUM7UUFFM0UsTUFBTSxzQkFBc0IsR0FBRyxJQUFJLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUNoRSx3QkFBd0IsRUFDeEIsTUFBTSxDQUNQLENBQUM7UUFDRixNQUFNLGFBQWEsR0FBRyxzQkFBc0IsRUFBRSxhQUFhLENBQUM7UUFFNUQsSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUNsQixPQUFPLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDLENBQUM7U0FDbEU7UUFFRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLHlDQUF5QyxDQUNwRSxlQUFlLENBQUMsWUFBWSxFQUM1QixNQUFNLEVBQ04sbUJBQW1CLENBQ3BCLENBQUM7UUFFRixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FDckUsU0FBUyxDQUFDLENBQUMsUUFBb0IsRUFBRSxFQUFFO1lBQ2pDLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUN6QixNQUFNLEVBQ04sMEJBQTBCLEVBQzFCLFFBQVEsQ0FDVCxDQUFDO1lBRUYsUUFBUSxDQUFDLEtBQUssR0FBRyxlQUFlLENBQUMsS0FBSyxDQUFDO1lBRXZDLGVBQWUsQ0FBQyxVQUFVLEdBQUcsUUFBUSxDQUFDO1lBRXRDLE9BQU8sRUFBRSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQzdCLENBQUMsQ0FBQyxFQUNGLFNBQVMsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUM1RCxVQUFVLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUNuQixNQUFNLEVBQUUsU0FBUyxFQUFFLEdBQUcsTUFBTSxDQUFDO1lBQzdCLE1BQU0sWUFBWSxHQUFHLDRCQUE0QixTQUFTLEVBQUUsQ0FBQztZQUU3RCxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBRXpELE9BQU8sVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7UUFDbkQsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFTyxrQkFBa0IsQ0FDeEIsTUFBdUIsRUFDdkIsTUFBMkI7UUFFM0IsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUNoQixRQUFRLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUNqQix5REFBeUQ7WUFDekQsSUFDRSxLQUFLO2dCQUNMLEtBQUssWUFBWSxpQkFBaUI7Z0JBQ2xDLEtBQUssQ0FBQyxLQUFLLFlBQVksYUFBYTtnQkFDcEMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssT0FBTyxFQUM1QjtnQkFDQSxNQUFNLEVBQUUsU0FBUyxFQUFFLDBCQUEwQixFQUFFLEdBQUcsTUFBTSxDQUFDO2dCQUN6RCxNQUFNLFlBQVksR0FBRyw0QkFBNEIsU0FBUywyQkFBMkIsQ0FBQztnQkFFdEYsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFFM0QsT0FBTyxLQUFLLENBQUMsMEJBQTBCLEdBQUcsSUFBSSxDQUFDLENBQUM7YUFDakQ7WUFFRCxPQUFPLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNqQyxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQzs4R0FwRlUsa0NBQWtDO2tIQUFsQyxrQ0FBa0MsY0FEckIsTUFBTTs7U0FDbkIsa0NBQWtDOzJGQUFsQyxrQ0FBa0M7a0JBRDlDLFVBQVU7bUJBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSHR0cEVycm9yUmVzcG9uc2UsIEh0dHBIZWFkZXJzIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mLCB0aHJvd0Vycm9yLCB0aW1lciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBjYXRjaEVycm9yLCBtZXJnZU1hcCwgcmV0cnlXaGVuLCBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IERhdGFTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vYXBpL2RhdGEuc2VydmljZSc7XHJcbmltcG9ydCB7IE9wZW5JZENvbmZpZ3VyYXRpb24gfSBmcm9tICcuLi8uLi9jb25maWcvb3BlbmlkLWNvbmZpZ3VyYXRpb24nO1xyXG5pbXBvcnQgeyBMb2dnZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vbG9nZ2luZy9sb2dnZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IFN0b3JhZ2VQZXJzaXN0ZW5jZVNlcnZpY2UgfSBmcm9tICcuLi8uLi9zdG9yYWdlL3N0b3JhZ2UtcGVyc2lzdGVuY2Uuc2VydmljZSc7XHJcbmltcG9ydCB7IFVybFNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy91cmwvdXJsLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBBdXRoUmVzdWx0LCBDYWxsYmFja0NvbnRleHQgfSBmcm9tICcuLi9jYWxsYmFjay1jb250ZXh0JztcclxuXHJcbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXHJcbmV4cG9ydCBjbGFzcyBSZWZyZXNoVG9rZW5DYWxsYmFja0hhbmRsZXJTZXJ2aWNlIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgdXJsU2VydmljZTogVXJsU2VydmljZSxcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyU2VydmljZTogTG9nZ2VyU2VydmljZSxcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGF0YVNlcnZpY2U6IERhdGFTZXJ2aWNlLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBzdG9yYWdlUGVyc2lzdGVuY2VTZXJ2aWNlOiBTdG9yYWdlUGVyc2lzdGVuY2VTZXJ2aWNlXHJcbiAgKSB7fVxyXG5cclxuICAvLyBTVEVQIDIgUmVmcmVzaCBUb2tlblxyXG4gIHJlZnJlc2hUb2tlbnNSZXF1ZXN0VG9rZW5zKFxyXG4gICAgY2FsbGJhY2tDb250ZXh0OiBDYWxsYmFja0NvbnRleHQsXHJcbiAgICBjb25maWc6IE9wZW5JZENvbmZpZ3VyYXRpb24sXHJcbiAgICBjdXN0b21QYXJhbXNSZWZyZXNoPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIH1cclxuICApOiBPYnNlcnZhYmxlPENhbGxiYWNrQ29udGV4dD4ge1xyXG4gICAgbGV0IGhlYWRlcnM6IEh0dHBIZWFkZXJzID0gbmV3IEh0dHBIZWFkZXJzKCk7XHJcblxyXG4gICAgaGVhZGVycyA9IGhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XHJcblxyXG4gICAgY29uc3QgYXV0aFdlbGxrbm93bkVuZHBvaW50cyA9IHRoaXMuc3RvcmFnZVBlcnNpc3RlbmNlU2VydmljZS5yZWFkKFxyXG4gICAgICAnYXV0aFdlbGxLbm93bkVuZFBvaW50cycsXHJcbiAgICAgIGNvbmZpZ1xyXG4gICAgKTtcclxuICAgIGNvbnN0IHRva2VuRW5kcG9pbnQgPSBhdXRoV2VsbGtub3duRW5kcG9pbnRzPy50b2tlbkVuZHBvaW50O1xyXG5cclxuICAgIGlmICghdG9rZW5FbmRwb2ludCkge1xyXG4gICAgICByZXR1cm4gdGhyb3dFcnJvcigoKSA9PiBuZXcgRXJyb3IoJ1Rva2VuIEVuZHBvaW50IG5vdCBkZWZpbmVkJykpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnVybFNlcnZpY2UuY3JlYXRlQm9keUZvckNvZGVGbG93UmVmcmVzaFRva2Vuc1JlcXVlc3QoXHJcbiAgICAgIGNhbGxiYWNrQ29udGV4dC5yZWZyZXNoVG9rZW4sXHJcbiAgICAgIGNvbmZpZyxcclxuICAgICAgY3VzdG9tUGFyYW1zUmVmcmVzaFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5kYXRhU2VydmljZS5wb3N0KHRva2VuRW5kcG9pbnQsIGRhdGEsIGNvbmZpZywgaGVhZGVycykucGlwZShcclxuICAgICAgc3dpdGNoTWFwKChyZXNwb25zZTogQXV0aFJlc3VsdCkgPT4ge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyU2VydmljZS5sb2dEZWJ1ZyhcclxuICAgICAgICAgIGNvbmZpZyxcclxuICAgICAgICAgICd0b2tlbiByZWZyZXNoIHJlc3BvbnNlOiAnLFxyXG4gICAgICAgICAgcmVzcG9uc2VcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXNwb25zZS5zdGF0ZSA9IGNhbGxiYWNrQ29udGV4dC5zdGF0ZTtcclxuXHJcbiAgICAgICAgY2FsbGJhY2tDb250ZXh0LmF1dGhSZXN1bHQgPSByZXNwb25zZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG9mKGNhbGxiYWNrQ29udGV4dCk7XHJcbiAgICAgIH0pLFxyXG4gICAgICByZXRyeVdoZW4oKGVycm9yKSA9PiB0aGlzLmhhbmRsZVJlZnJlc2hSZXRyeShlcnJvciwgY29uZmlnKSksXHJcbiAgICAgIGNhdGNoRXJyb3IoKGVycm9yKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBhdXRob3JpdHkgfSA9IGNvbmZpZztcclxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgT2lkY1NlcnZpY2UgY29kZSByZXF1ZXN0ICR7YXV0aG9yaXR5fWA7XHJcblxyXG4gICAgICAgIHRoaXMubG9nZ2VyU2VydmljZS5sb2dFcnJvcihjb25maWcsIGVycm9yTWVzc2FnZSwgZXJyb3IpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcigoKSA9PiBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSk7XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBoYW5kbGVSZWZyZXNoUmV0cnkoXHJcbiAgICBlcnJvcnM6IE9ic2VydmFibGU8YW55PixcclxuICAgIGNvbmZpZzogT3BlbklkQ29uZmlndXJhdGlvblxyXG4gICk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICByZXR1cm4gZXJyb3JzLnBpcGUoXHJcbiAgICAgIG1lcmdlTWFwKChlcnJvcikgPT4ge1xyXG4gICAgICAgIC8vIHJldHJ5IHRva2VuIHJlZnJlc2ggaWYgdGhlcmUgaXMgbm8gaW50ZXJuZXQgY29ubmVjdGlvblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIGVycm9yICYmXHJcbiAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEh0dHBFcnJvclJlc3BvbnNlICYmXHJcbiAgICAgICAgICBlcnJvci5lcnJvciBpbnN0YW5jZW9mIFByb2dyZXNzRXZlbnQgJiZcclxuICAgICAgICAgIGVycm9yLmVycm9yLnR5cGUgPT09ICdlcnJvcidcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGNvbnN0IHsgYXV0aG9yaXR5LCByZWZyZXNoVG9rZW5SZXRyeUluU2Vjb25kcyB9ID0gY29uZmlnO1xyXG4gICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYE9pZGNTZXJ2aWNlIGNvZGUgcmVxdWVzdCAke2F1dGhvcml0eX0gLSBubyBpbnRlcm5ldCBjb25uZWN0aW9uYDtcclxuXHJcbiAgICAgICAgICB0aGlzLmxvZ2dlclNlcnZpY2UubG9nV2FybmluZyhjb25maWcsIGVycm9yTWVzc2FnZSwgZXJyb3IpO1xyXG5cclxuICAgICAgICAgIHJldHVybiB0aW1lcihyZWZyZXNoVG9rZW5SZXRyeUluU2Vjb25kcyAqIDEwMDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoKCkgPT4gZXJyb3IpO1xyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIl19