import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
class JwkExtractor {
    extractJwk(keys, spec, throwOnEmpty = true) {
        if (0 === keys.length) {
            throw JwkExtractorInvalidArgumentError;
        }
        const foundKeys = keys
            .filter((k) => (spec?.kid ? k['kid'] === spec.kid : true))
            .filter((k) => (spec?.use ? k['use'] === spec.use : true))
            .filter((k) => (spec?.kty ? k['kty'] === spec.kty : true));
        if (foundKeys.length === 0 && throwOnEmpty) {
            throw JwkExtractorNoMatchingKeysError;
        }
        if (foundKeys.length > 1 && (null === spec || undefined === spec)) {
            throw JwkExtractorSeveralMatchingKeysError;
        }
        return foundKeys;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: JwkExtractor, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: JwkExtractor, providedIn: 'root' }); }
}
export { JwkExtractor };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: JwkExtractor, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
function buildErrorName(name) {
    return JwkExtractor.name + ': ' + name;
}
export const JwkExtractorInvalidArgumentError = {
    name: buildErrorName('InvalidArgumentError'),
    message: 'Array of keys was empty. Unable to extract',
};
export const JwkExtractorNoMatchingKeysError = {
    name: buildErrorName('NoMatchingKeysError'),
    message: 'No key found matching the spec',
};
export const JwkExtractorSeveralMatchingKeysError = {
    name: buildErrorName('SeveralMatchingKeysError'),
    message: 'More than one key found. Please use spec to filter',
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiandrLmV4dHJhY3Rvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItYXV0aC1vaWRjLWNsaWVudC9zcmMvbGliL2V4dHJhY3RvcnMvandrLmV4dHJhY3Rvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDOztBQUUzQyxNQUNhLFlBQVk7SUFDdkIsVUFBVSxDQUNSLElBQWtCLEVBQ2xCLElBQW1ELEVBQ25ELFlBQVksR0FBRyxJQUFJO1FBRW5CLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDckIsTUFBTSxnQ0FBZ0MsQ0FBQztTQUN4QztRQUVELE1BQU0sU0FBUyxHQUFHLElBQUk7YUFDbkIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN6RCxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3pELE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUU3RCxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLFlBQVksRUFBRTtZQUMxQyxNQUFNLCtCQUErQixDQUFDO1NBQ3ZDO1FBRUQsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLElBQUksU0FBUyxLQUFLLElBQUksQ0FBQyxFQUFFO1lBQ2pFLE1BQU0sb0NBQW9DLENBQUM7U0FDNUM7UUFFRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDOzhHQXhCVSxZQUFZO2tIQUFaLFlBQVksY0FEQyxNQUFNOztTQUNuQixZQUFZOzJGQUFaLFlBQVk7a0JBRHhCLFVBQVU7bUJBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFOztBQTRCbEMsU0FBUyxjQUFjLENBQUMsSUFBWTtJQUNsQyxPQUFPLFlBQVksQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQztBQUN6QyxDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0sZ0NBQWdDLEdBQUc7SUFDOUMsSUFBSSxFQUFFLGNBQWMsQ0FBQyxzQkFBc0IsQ0FBQztJQUM1QyxPQUFPLEVBQUUsNENBQTRDO0NBQ3RELENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSwrQkFBK0IsR0FBRztJQUM3QyxJQUFJLEVBQUUsY0FBYyxDQUFDLHFCQUFxQixDQUFDO0lBQzNDLE9BQU8sRUFBRSxnQ0FBZ0M7Q0FDMUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLG9DQUFvQyxHQUFHO0lBQ2xELElBQUksRUFBRSxjQUFjLENBQUMsMEJBQTBCLENBQUM7SUFDaEQsT0FBTyxFQUFFLG9EQUFvRDtDQUM5RCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcclxuZXhwb3J0IGNsYXNzIEp3a0V4dHJhY3RvciB7XHJcbiAgZXh0cmFjdEp3ayhcclxuICAgIGtleXM6IEpzb25XZWJLZXlbXSxcclxuICAgIHNwZWM/OiB7IGtpZD86IHN0cmluZzsgdXNlPzogc3RyaW5nOyBrdHk/OiBzdHJpbmcgfSxcclxuICAgIHRocm93T25FbXB0eSA9IHRydWVcclxuICApOiBKc29uV2ViS2V5W10ge1xyXG4gICAgaWYgKDAgPT09IGtleXMubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IEp3a0V4dHJhY3RvckludmFsaWRBcmd1bWVudEVycm9yO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGZvdW5kS2V5cyA9IGtleXNcclxuICAgICAgLmZpbHRlcigoaykgPT4gKHNwZWM/LmtpZCA/IGtbJ2tpZCddID09PSBzcGVjLmtpZCA6IHRydWUpKVxyXG4gICAgICAuZmlsdGVyKChrKSA9PiAoc3BlYz8udXNlID8ga1sndXNlJ10gPT09IHNwZWMudXNlIDogdHJ1ZSkpXHJcbiAgICAgIC5maWx0ZXIoKGspID0+IChzcGVjPy5rdHkgPyBrWydrdHknXSA9PT0gc3BlYy5rdHkgOiB0cnVlKSk7XHJcblxyXG4gICAgaWYgKGZvdW5kS2V5cy5sZW5ndGggPT09IDAgJiYgdGhyb3dPbkVtcHR5KSB7XHJcbiAgICAgIHRocm93IEp3a0V4dHJhY3Rvck5vTWF0Y2hpbmdLZXlzRXJyb3I7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZvdW5kS2V5cy5sZW5ndGggPiAxICYmIChudWxsID09PSBzcGVjIHx8IHVuZGVmaW5lZCA9PT0gc3BlYykpIHtcclxuICAgICAgdGhyb3cgSndrRXh0cmFjdG9yU2V2ZXJhbE1hdGNoaW5nS2V5c0Vycm9yO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmb3VuZEtleXM7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBidWlsZEVycm9yTmFtZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIHJldHVybiBKd2tFeHRyYWN0b3IubmFtZSArICc6ICcgKyBuYW1lO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgSndrRXh0cmFjdG9ySW52YWxpZEFyZ3VtZW50RXJyb3IgPSB7XHJcbiAgbmFtZTogYnVpbGRFcnJvck5hbWUoJ0ludmFsaWRBcmd1bWVudEVycm9yJyksXHJcbiAgbWVzc2FnZTogJ0FycmF5IG9mIGtleXMgd2FzIGVtcHR5LiBVbmFibGUgdG8gZXh0cmFjdCcsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgSndrRXh0cmFjdG9yTm9NYXRjaGluZ0tleXNFcnJvciA9IHtcclxuICBuYW1lOiBidWlsZEVycm9yTmFtZSgnTm9NYXRjaGluZ0tleXNFcnJvcicpLFxyXG4gIG1lc3NhZ2U6ICdObyBrZXkgZm91bmQgbWF0Y2hpbmcgdGhlIHNwZWMnLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEp3a0V4dHJhY3RvclNldmVyYWxNYXRjaGluZ0tleXNFcnJvciA9IHtcclxuICBuYW1lOiBidWlsZEVycm9yTmFtZSgnU2V2ZXJhbE1hdGNoaW5nS2V5c0Vycm9yJyksXHJcbiAgbWVzc2FnZTogJ01vcmUgdGhhbiBvbmUga2V5IGZvdW5kLiBQbGVhc2UgdXNlIHNwZWMgdG8gZmlsdGVyJyxcclxufTtcclxuIl19