import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "../storage/storage-persistence.service";
import * as i2 from "@angular/router";
const STORAGE_KEY = 'redirect';
class AutoLoginService {
    constructor(storageService, router) {
        this.storageService = storageService;
        this.router = router;
    }
    checkSavedRedirectRouteAndNavigate(config) {
        const savedRouteForRedirect = this.getStoredRedirectRoute(config);
        if (savedRouteForRedirect != null) {
            this.deleteStoredRedirectRoute(config);
            this.router.navigateByUrl(savedRouteForRedirect);
        }
    }
    /**
     * Saves the redirect URL to storage.
     *
     * @param config The OpenId configuration.
     * @param url The redirect URL to save.
     */
    saveRedirectRoute(config, url) {
        this.storageService.write(STORAGE_KEY, url, config);
    }
    /**
     * Gets the stored redirect URL from storage.
     */
    getStoredRedirectRoute(config) {
        return this.storageService.read(STORAGE_KEY, config);
    }
    /**
     * Removes the redirect URL from storage.
     */
    deleteStoredRedirectRoute(config) {
        this.storageService.remove(STORAGE_KEY, config);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: AutoLoginService, deps: [{ token: i1.StoragePersistenceService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: AutoLoginService, providedIn: 'root' }); }
}
export { AutoLoginService };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: AutoLoginService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.StoragePersistenceService }, { type: i2.Router }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0by1sb2dpbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci1hdXRoLW9pZGMtY2xpZW50L3NyYy9saWIvYXV0by1sb2dpbi9hdXRvLWxvZ2luLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7OztBQUszQyxNQUFNLFdBQVcsR0FBRyxVQUFVLENBQUM7QUFFL0IsTUFDYSxnQkFBZ0I7SUFDM0IsWUFDbUIsY0FBeUMsRUFDekMsTUFBYztRQURkLG1CQUFjLEdBQWQsY0FBYyxDQUEyQjtRQUN6QyxXQUFNLEdBQU4sTUFBTSxDQUFRO0lBQzlCLENBQUM7SUFFSixrQ0FBa0MsQ0FBQyxNQUEyQjtRQUM1RCxNQUFNLHFCQUFxQixHQUFHLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVsRSxJQUFJLHFCQUFxQixJQUFJLElBQUksRUFBRTtZQUNqQyxJQUFJLENBQUMseUJBQXlCLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdkMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMscUJBQXFCLENBQUMsQ0FBQztTQUNsRDtJQUNILENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGlCQUFpQixDQUFDLE1BQTJCLEVBQUUsR0FBVztRQUN4RCxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRDs7T0FFRztJQUNLLHNCQUFzQixDQUFDLE1BQTJCO1FBQ3hELE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7T0FFRztJQUNLLHlCQUF5QixDQUFDLE1BQTJCO1FBQzNELElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNsRCxDQUFDOzhHQXJDVSxnQkFBZ0I7a0hBQWhCLGdCQUFnQixjQURILE1BQU07O1NBQ25CLGdCQUFnQjsyRkFBaEIsZ0JBQWdCO2tCQUQ1QixVQUFVO21CQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHsgT3BlbklkQ29uZmlndXJhdGlvbiB9IGZyb20gJy4uL2NvbmZpZy9vcGVuaWQtY29uZmlndXJhdGlvbic7XHJcbmltcG9ydCB7IFN0b3JhZ2VQZXJzaXN0ZW5jZVNlcnZpY2UgfSBmcm9tICcuLi9zdG9yYWdlL3N0b3JhZ2UtcGVyc2lzdGVuY2Uuc2VydmljZSc7XHJcblxyXG5jb25zdCBTVE9SQUdFX0tFWSA9ICdyZWRpcmVjdCc7XHJcblxyXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxyXG5leHBvcnQgY2xhc3MgQXV0b0xvZ2luU2VydmljZSB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0b3JhZ2VTZXJ2aWNlOiBTdG9yYWdlUGVyc2lzdGVuY2VTZXJ2aWNlLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSByb3V0ZXI6IFJvdXRlclxyXG4gICkge31cclxuXHJcbiAgY2hlY2tTYXZlZFJlZGlyZWN0Um91dGVBbmROYXZpZ2F0ZShjb25maWc6IE9wZW5JZENvbmZpZ3VyYXRpb24pOiB2b2lkIHtcclxuICAgIGNvbnN0IHNhdmVkUm91dGVGb3JSZWRpcmVjdCA9IHRoaXMuZ2V0U3RvcmVkUmVkaXJlY3RSb3V0ZShjb25maWcpO1xyXG5cclxuICAgIGlmIChzYXZlZFJvdXRlRm9yUmVkaXJlY3QgIT0gbnVsbCkge1xyXG4gICAgICB0aGlzLmRlbGV0ZVN0b3JlZFJlZGlyZWN0Um91dGUoY29uZmlnKTtcclxuICAgICAgdGhpcy5yb3V0ZXIubmF2aWdhdGVCeVVybChzYXZlZFJvdXRlRm9yUmVkaXJlY3QpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2F2ZXMgdGhlIHJlZGlyZWN0IFVSTCB0byBzdG9yYWdlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGNvbmZpZyBUaGUgT3BlbklkIGNvbmZpZ3VyYXRpb24uXHJcbiAgICogQHBhcmFtIHVybCBUaGUgcmVkaXJlY3QgVVJMIHRvIHNhdmUuXHJcbiAgICovXHJcbiAgc2F2ZVJlZGlyZWN0Um91dGUoY29uZmlnOiBPcGVuSWRDb25maWd1cmF0aW9uLCB1cmw6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgdGhpcy5zdG9yYWdlU2VydmljZS53cml0ZShTVE9SQUdFX0tFWSwgdXJsLCBjb25maWcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgc3RvcmVkIHJlZGlyZWN0IFVSTCBmcm9tIHN0b3JhZ2UuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRTdG9yZWRSZWRpcmVjdFJvdXRlKGNvbmZpZzogT3BlbklkQ29uZmlndXJhdGlvbik6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlU2VydmljZS5yZWFkKFNUT1JBR0VfS0VZLCBjb25maWcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyB0aGUgcmVkaXJlY3QgVVJMIGZyb20gc3RvcmFnZS5cclxuICAgKi9cclxuICBwcml2YXRlIGRlbGV0ZVN0b3JlZFJlZGlyZWN0Um91dGUoY29uZmlnOiBPcGVuSWRDb25maWd1cmF0aW9uKTogdm9pZCB7XHJcbiAgICB0aGlzLnN0b3JhZ2VTZXJ2aWNlLnJlbW92ZShTVE9SQUdFX0tFWSwgY29uZmlnKTtcclxuICB9XHJcbn1cclxuIl19